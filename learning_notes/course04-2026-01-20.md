# Course 04 学习笔记（Tool Use Design Pattern）

- 日期：2026-01-20
- 学习时长：60min

## 课程目标与核心收获
- 掌握工具/函数调用的完整闭环：序列化函数描述 → 模型返回 tool_calls → 执行工具 → 回传结果 → 最终回答。
- 能编写清晰的 JSON Schema（name/description/parameters/required），并实现参数校验与安全边界。

## 关键术语与模式（英文保留并解释）
- Function Calling：模型以结构化形式请求调用某个函数（工具），返回函数名和参数。
- Tool / Plugin：可重用的代码能力（本地函数或外部 API）；在框架中常以插件形式注册与发现。
- Tool Calls：模型输出的“函数名 + 参数”的调用指令，不是最终答案。
- JSON Schema：以 JSON 描述函数参数的结构、类型和必填项，供模型理解与构造正确请求。
- Serialization：将函数签名/参数说明转换为模型可读的结构化格式（通常 JSON/Schema）。
- Tool Message：工具执行后的结果，以特殊消息类型追加到会话，供模型综合生成回复。
- Thread / Session：会话上下文载体，保存消息历史与状态，支持并发与多会话隔离。
- Validation & Permissions：参数校验、权限控制、超时/重试与错误处理，防止越权与注入。
- Tool Routing / Selection：根据用户意图与上下文选择合适工具的策略（可由模型或框架路由）。

## 示例与实践要点
- 定义工具模式：name/description/parameters（含 required），示例 get_current_time(location: string)。
- 首次调用：messages + tools → 模型返回 tool_calls（选择函数与参数）。
- 执行工具：解析 tool_call.function.arguments（JSON），运行本地函数并得到结果。
- 回传与二次调用：将工具结果以 role="tool" 的消息追加，再次调用模型生成自然语言答案。
- Notebook 实操（MAF）：创建 ChatAgent、注册工具、get_new_thread() 建立会话，await agent.run(...) 获得响应；取结果时注意 `messages[-1]` 和 `contents[0]` 的安全访问。

## 易错点与排查
- 环境变量未加载：使用 python-dotenv 的 load_dotenv() 并打印检查 GITHUB_ENDPOINT/TOKEN/MODEL_ID。
- tool_calls 为空：检查工具描述是否清晰、模型是否支持函数调用、tool_choice 设置是否正确。
- 索引越界：访问 messages[-1] 与 contents[0] 前先判断长度与类型。
- 参数解析失败：确保 arguments 是合法 JSON，做好类型/必填项校验与错误提示。
- 权限/安全：为外部 API/数据库设最小权限与速率限制，加入超时/重试与错误分支（只读、重试退避、错误兜底）。

## 参考与下一步
- 代码示例：
  - [04-tool-use/code_samples/04-python-agent-framework.ipynb](../04-tool-use/code_samples/04-python-agent-framework.ipynb)
  - [04-tool-use/code_samples/04-autogen.ipynb](../04-tool-use/code_samples/04-autogen.ipynb)
- 下一步：
  - 扩展多工具：天气、费用、活动推荐，练习工具选择与结果归并。
  - 为工具增加参数验证、权限与错误恢复，提升鲁棒性。
  - 对比使用 Semantic Kernel/Agent Service 的自动序列化与往返通信。

## 下节课预习（Agentic RAG）
- 主题：RAG（检索增强生成）与上下文增强，让代理用外部知识库回答问题。
- 关键术语：Embeddings、Vector DB、Retriever、Chunking、Context Window、Grounding。
- 能力点：检索融合（retrieve→rank→compose）、引用证据、避免幻觉、个性化知识注入。
- 练习建议：为代理接入向量库，保存与检索资料，结合工具使用生成更可靠答案。